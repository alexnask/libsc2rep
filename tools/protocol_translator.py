# This is a python 2.7 script that translates a prtocol file from the sc2protocol repository to a C++ schema definition used here
# Warning, templates aplenty will be generated
#  yes, I know this code is horrible btw, I just put it together really fast, deal with it :D
import sys

symMap = {
	"_struct" : "Struct",
	"_array"  : "Array",
	"_optional" : "Optional",
	"_bitarray" : "BitArray",
	"_blob" : "Blob",
	"_bool" : "Bool",
	"_fourcc" : "FourCC",
	"_int" : "Int",
	"_choice" : "Choice"
}

def getBitpackEntry(tup, dic):
	ret = symMap[tup[0]]
	if ret == "Struct":
		ret += "<"
		first = True
		thingList = sorted(tup[1][0], key=lambda thing: abs(thing[2]))
		for thing in thingList:
			if first:
				first = False
			else:
				ret += ", "
			newTup = dic[thing[1]]
			ret += getBitpackEntry(newTup, dic)
		ret += ">"
	elif ret == "Array":
		ret += "<"
		thing = dic[tup[1][1]]
		bounds = str(tup[1][0][0]) + ", " + str(tup[1][0][1]) + ", "
		ret += bounds + getBitpackEntry(thing, dic) + ">"
	elif ret == "Optional":
		ret += "<"
		thing = dic[tup[1][0]]
		ret += getBitpackEntry(thing, dic) + ">"
	elif ret == "Int":
		ret += "<"
		bounds = str(tup[1][0][0]) + ", " + str(tup[1][0][1])
		ret += bounds + ">"
	elif ret == "BitArray":
		ret += "<"
		bounds = str(tup[1][0][0]) + ", " + str(tup[1][0][1])
		ret += bounds + ">"
	elif ret == "Blob":
		ret += "<"
		bounds = str(tup[1][0][0]) + ", " + str(tup[1][0][1])
		ret += bounds + ">"
	elif ret == "Choice":
		ret += "<"
		ret += str(tup[1][0][0]) + ", " + str(tup[1][0][1])
		thingDict = tup[1][1]
		for tag, thing in thingDict.items():
			ret += ", sc2::bitpack::Pair<" + str(tag) + ", " + getBitpackEntry(dic[thing[1]]) + ">"
		ret += ">"
	return "sc2::bitpack::" + ret

def getVersionedEntry(tup, dic):
	ret = symMap[tup[0]]
	if ret == "Struct":
		ret += "<"
		first = True
		thingList = sorted(tup[1][0], key=lambda thing: thing[2])
		for thing in thingList:
			if first:
				first = False
			else:
				ret += ", "
			newTup = dic[thing[1]]
			ret += getVersionedEntry(newTup, dic)
		ret += ">"
	elif ret == "Array":
		ret += "<"
		thing = dic[tup[1][1]]
		ret += getVersionedEntry(thing, dic) + ">"
	elif ret == "Optional":
		ret += "<"
		thing = dic[tup[1][0]]
		ret += getVersionedEntry(thing, dic) + ">"
	return "sc2::versioned::" + ret

if __name__ == "__main__":
	if len(sys.argv) < 3:
		print "Usage: `python protocol_translator.py blizz_protocol_number_xxxxx.py output_file.cpp`"
		exit(0)
	proto = __import__(sys.argv[1])
	output = sys.argv[2]

	with open(output, 'w+') as f:
		f.write("""#include <sc2/serialized/schema.hpp>
#include <sc2/serialized/bitpack.hpp>

// Autogenerated by protocol_translator, please make sure not too stare at those generics for so long :)
typedef sc2::versioned::Schema<""")
		details = proto.typeinfos[proto.game_details_typeid]
		f.write(getVersionedEntry(details, proto.typeinfos))
		f.write("> DetailsSchema;\ntypedef sc2::versioned::Schema<")
		header = proto.typeinfos[proto.replay_header_typeid]
		f.write(getVersionedEntry(header, proto.typeinfos))
		f.write("> HeaderSchema;\ntypedef sc2::bitpack::Schema<")
		initData = proto.typeinfos[proto.replay_initdata_typeid]
		f.write(getBitpackEntry(initData, proto.typeinfos))
		f.write("> InitDataSchema;")

